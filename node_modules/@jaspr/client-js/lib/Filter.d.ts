export declare enum Constants {
    LOGICAL_EQUAL = "eq",
    LOGICAL_NOT_EQUAL = "ne",
    LOGICAL_GREATER_THAN = "gt",
    LOGICAL_GREATER_THAN_OR_EQUAL = "ge",
    LOGICAL_LOWER_THAN = "lt",
    LOGICAL_LOWER_THAN_OR_EQUAL = "le",
    LOGICAL_AND = "and",
    LOGICAL_OR = "or",
    LOGICAL_NOT = "not",
    LOGICAL_HAS = "has",
    LOGICAL_IN = "in",
    LOGICAL_BETWEEN = "be",
    ARITHMETIC_ADDITION = "add",
    ARITHMETIC_SUBTRACTION = "sub",
    ARITHMETIC_NEGATION = "-",
    ARITHMETIC_MULTIPLICATION = "mul",
    ARITHMETIC_DIVISION = "div",
    ARITHMETIC_MODULO = "mod",
    FUNCTION_STARTS_WITH = "startsWith",
    FUNCTION_ENDS_WITH = "endsWith",
    FUNCTION_CONTAINS = "contains",
    FUNCTION_CONCAT = "concat",
    FUNCTION_INDEX_OF = "indexof",
    FUNCTION_LENGTH = "length",
    FUNCTION_SUBSTRING = "substring",
    FUNCTION_MATCHES_PATTERN = "matchesPattern",
    FUNCTION_TO_LOWER = "tolower",
    FUNCTION_TO_UPPER = "toupper",
    FUNCTION_TRIM = "trim",
    FUNCTION_ANY = "any",
    FUNCTION_ALL = "all",
    FUNCTION_DATE = "date",
    FUNCTION_DAY = "day",
    FUNCTION_HOUR = "hour",
    FUNCTION_MINUTE = "minute",
    FUNCTION_MONTH = "month",
    FUNCTION_NOW = "now",
    FUNCTION_SECOND = "second",
    FUNCTION_TIME = "time",
    FUNCTION_YEAR = "year",
    FUNCTION_CEILING = "ceiling",
    FUNCTION_FLOOR = "floor",
    FUNCTION_ROUND = "round"
}
export interface Expression {
    express(): string;
}
export interface ExpressionGroup extends Expression {
    addExpression(expression: Expression): ExpressionGroup;
}
export type LiteralExpression = (value: any) => Expression;
export type FieldExpression = (name: string) => Expression;
export type BinaryExpression = (left: Expression, operator: Constants, right: Expression) => Expression;
export type FunctionExpression = (fn: Constants, args: Expression[]) => Expression;
export type GroupExpression = (expressions: Expression[], operator: Constants) => ExpressionGroup;
export type UnaryExpression = (value: Expression, operator: Constants) => Expression;
export interface ExpressionBuilder {
    literal: LiteralExpression;
    field: FieldExpression;
    binaryExpression: BinaryExpression;
    functionExpression: FunctionExpression;
    groupExpression: GroupExpression;
    unaryExpression: UnaryExpression;
}
