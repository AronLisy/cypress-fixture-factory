import ODataExpressionStrategy from "./ODataExpressionStrategy";
import { Constants } from "./Expression";
export default function (strategy) {
    const _builder = strategy !== null && strategy !== void 0 ? strategy : ODataExpressionStrategy;
    let _ex = null;
    let _previous = null;
    let _glue;
    let _left;
    let _op;
    let _right;
    const compose = {
        and() {
            _previous = this.build();
            _glue = Constants.LOGICAL_AND;
            _ex = null;
            return where;
        },
        or() {
            _previous = this.build();
            _glue = Constants.LOGICAL_OR;
            _ex = null;
            return where;
        },
        build() {
            if (!_ex) {
                if (_left && _op && _right) {
                    _ex = _builder.binaryExpression(_left, _op, _right);
                }
                else {
                    return null;
                }
            }
            if (_previous) {
                _ex = _builder.binaryExpression(_previous, _glue, _ex);
            }
            return _ex;
        }
    };
    const value = {
        right(expression) {
            _right = expression;
            return compose;
        },
        literal(value) {
            _right = _builder.literal(value);
            return compose;
        }
    };
    const range = {
        literal(from, to) {
            _right = _builder.literal([from, to]);
            return compose;
        }
    };
    const operator = {
        add(fieldOrValue) {
            _left = _builder.binaryExpression(_left, Constants.ARITHMETIC_ADDITION, fieldOrValue);
            return this;
        },
        ceiling() {
            _left = _builder.functionExpression(Constants.FUNCTION_CEILING, [_left]);
            return this;
        },
        concat(fieldOrValue) {
            _left = _builder.functionExpression(Constants.FUNCTION_CONCAT, [_left, fieldOrValue]);
            return this;
        },
        date() {
            _left = _builder.functionExpression(Constants.FUNCTION_DATE, [_left]);
            return this;
        },
        day() {
            _left = _builder.functionExpression(Constants.FUNCTION_DAY, [_left]);
            return this;
        },
        div(fieldOrValue) {
            _left = _builder.binaryExpression(_left, Constants.ARITHMETIC_DIVISION, fieldOrValue);
            return this;
        },
        floor() {
            _left = _builder.functionExpression(Constants.FUNCTION_FLOOR, [_left]);
            return this;
        },
        has() {
            _op = Constants.LOGICAL_HAS;
            return value;
        },
        hour() {
            _left = _builder.functionExpression(Constants.FUNCTION_HOUR, [_left]);
            return this;
        },
        indexOf(text) {
            _left = _builder.functionExpression(Constants.FUNCTION_INDEX_OF, [_left, _builder.literal(text)]);
            return this;
        },
        lengthOf() {
            _left = _builder.functionExpression(Constants.FUNCTION_LENGTH, [_left]);
            return this;
        },
        matchesPattern(pattern) {
            _ex = _builder.functionExpression(Constants.FUNCTION_MATCHES_PATTERN, [_left, _builder.literal(pattern)]);
            return compose;
        },
        minute() {
            _left = _builder.functionExpression(Constants.FUNCTION_MINUTE, [_left]);
            return this;
        },
        mod(fieldOrValue) {
            _left = _builder.binaryExpression(_left, Constants.ARITHMETIC_MODULO, fieldOrValue);
            return this;
        },
        month() {
            _left = _builder.functionExpression(Constants.FUNCTION_MONTH, [_left]);
            return this;
        },
        mul(fieldOrValue) {
            _left = _builder.binaryExpression(_left, Constants.ARITHMETIC_MULTIPLICATION, fieldOrValue);
            return this;
        },
        neg() {
            _left = _builder.unaryExpression(_left, Constants.ARITHMETIC_NEGATION);
            return this;
        },
        not() {
            _left = _builder.unaryExpression(_left, Constants.LOGICAL_NOT);
            return this;
        },
        round() {
            _left = _builder.functionExpression(Constants.FUNCTION_ROUND, [_left]);
            return this;
        },
        second() {
            _left = _builder.functionExpression(Constants.FUNCTION_SECOND, [_left]);
            return this;
        },
        sub(fieldOrValue) {
            _left = _builder.binaryExpression(_left, Constants.ARITHMETIC_SUBTRACTION, fieldOrValue);
            return this;
        },
        substring(length) {
            _left = _builder.functionExpression(Constants.FUNCTION_SUBSTRING, [_left, _builder.literal(length)]);
            return this;
        },
        time() {
            _left = _builder.functionExpression(Constants.FUNCTION_SECOND, [_left]);
            return this;
        },
        toLower() {
            _left = _builder.functionExpression(Constants.FUNCTION_TO_LOWER, [_left]);
            return this;
        },
        toUpper() {
            _left = _builder.functionExpression(Constants.FUNCTION_TO_UPPER, [_left]);
            return this;
        },
        trim() {
            _left = _builder.functionExpression(Constants.FUNCTION_TRIM, [_left]);
            return this;
        },
        year() {
            _left = _builder.functionExpression(Constants.FUNCTION_SECOND, [_left]);
            return this;
        },
        be() {
            _op = Constants.LOGICAL_BETWEEN;
            return range;
        },
        contains(text) {
            _ex = _builder.functionExpression(Constants.FUNCTION_CONTAINS, [_left, _builder.literal(text)]);
            return compose;
        },
        endsWith(text) {
            _ex = _builder.functionExpression(Constants.FUNCTION_ENDS_WITH, [_left, _builder.literal(text)]);
            return compose;
        },
        eq() {
            _op = Constants.LOGICAL_EQUAL;
            return value;
        },
        ge() {
            _op = Constants.LOGICAL_GREATER_THAN_OR_EQUAL;
            return value;
        },
        gt() {
            _op = Constants.LOGICAL_GREATER_THAN;
            return value;
        },
        in() {
            _op = Constants.LOGICAL_IN;
            return value;
        },
        le() {
            _op = Constants.LOGICAL_LOWER_THAN_OR_EQUAL;
            return value;
        },
        lt() {
            _op = Constants.LOGICAL_LOWER_THAN;
            return value;
        },
        ne() {
            _op = Constants.LOGICAL_NOT_EQUAL;
            return value;
        },
        startsWith(text) {
            _ex = _builder.functionExpression(Constants.FUNCTION_STARTS_WITH, [_left, _builder.literal(text)]);
            return compose;
        }
    };
    const where = {
        field(name) {
            _left = _builder.field(name);
            return operator;
        }
    };
    const grouping = {
        conjunct(...expressions) {
            _ex = _builder.groupExpression(expressions, Constants.LOGICAL_AND);
            return Object.assign(Object.assign({}, compose), grouping);
        },
        disjunct(...expressions) {
            _ex = _builder.groupExpression(expressions, Constants.LOGICAL_OR);
            return Object.assign(Object.assign({}, compose), grouping);
        }
    };
    return Object.assign(Object.assign(Object.assign({}, where), compose), grouping);
}
