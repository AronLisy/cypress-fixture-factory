import { Constants } from "./Expression";
const field = function (name) {
    return {
        express() {
            return name;
        }
    };
};
const literal = function (value) {
    let _value;
    if (value === undefined) {
        throw new Error('Expected value to by one of [null, Date, String, Number, Boolean, Array], but got ' + typeof value);
    }
    if (value === null) {
        _value = 'null';
    }
    else {
        if (typeof value.express === 'function') {
            _value = value.express();
        }
        else if (value instanceof Date) {
            _value = `datetime'${value.toISOString()}'`;
        }
        else if (value instanceof Array) {
            value = value.map(item => literal(item).express());
            _value = `(${value.join(',')})`;
        }
        else if (typeof value === 'string') {
            _value = `'${value.replace(`'`, `''`)}'`;
        }
        else if (typeof value === 'boolean') {
            _value = value ? 'true' : 'false';
        }
        else if (typeof value === 'number') {
            _value = value.toString();
        }
        else {
            throw new Error('Expected value to by one of [null, Date, String, Number, Boolean, Array], but got ' + typeof value);
        }
    }
    return {
        express() {
            return _value;
        }
    };
};
const groupExpression = function (expressions, operator) {
    if (operator !== Constants.LOGICAL_AND && operator !== Constants.LOGICAL_OR) {
        throw Error("Invalid group operator. Possible values are: [AND, OR].");
    }
    return {
        addExpression(expression) {
            expressions.push(expression);
            return this;
        },
        express() {
            return '(' + expressions.map(item => item.express()).join(` ${operator} `) + ')';
        }
    };
};
const binaryExpression = function (left, operator, right) {
    return {
        express() {
            return `${left.express()} ${operator} ${right.express()}`;
        }
    };
};
const functionExpression = function (fn, args) {
    return {
        express() {
            let res = `${fn}(`;
            if (args.length > 0) {
                let comma = false;
                for (const arg of args) {
                    if (comma) {
                        res += ',';
                    }
                    res += `${arg.express()}`;
                    comma = true;
                }
            }
            res += `)`;
            return res;
        }
    };
};
const unaryExpression = function (value, operator) {
    return {
        express() {
            return `${operator} ${value.express()}`;
        }
    };
};
const strategy = {
    literal,
    field,
    groupExpression,
    binaryExpression,
    functionExpression,
    unaryExpression
};
export default strategy;
