import Client from "./Client";
import { Expression } from "./Expression";
import { CompoundDocument, Link, Meta, Relationship, Resource, ResourceIdentifier } from "./JSONAPI";
import useNativeFetchClient from "./NativeFetchClient";
import ODataExpressionStrategy from "./ODataExpressionStrategy";
import PrettyExpressionBuilder from "./PrettyExpressionBuilder";
import QuatrodotExpressionStrategy from "./QuatrodotExpressionStrategy";
type RecursivePartial<T> = {
    [P in keyof T]?: RecursivePartial<T[P]> | P;
};
export type PartialResource<T extends Resource> = RecursivePartial<T>;
export interface ResourceProxy<T extends Resource> extends Resource {
    relationships?: {
        [key: string]: ToOneRelationshipProxy | ToManyRelationshipProxy;
    };
    fields(type: string, fields: string[]): ResourceProxy<T>;
    include(pointer: string): ResourceProxy<T>;
    param(name: string, value: string): ResourceProxy<T>;
    self(signal?: AbortSignal): Promise<ResourceDocument<T>>;
    update(data: PartialResource<Resource>, signal?: AbortSignal): Promise<ResourceDocument<T>>;
    delete(signal?: AbortSignal): Promise<ResourceDocument<T> | undefined>;
}
export type ResourceObject<T extends Resource> = T & ResourceProxy<T>;
export interface ToOneRelationshipProxy {
    data?: ResourceIdentifier | null;
    self(signal?: AbortSignal): Promise<ResourceIdentifierDocument>;
    related<T extends Resource>(signal?: AbortSignal): Promise<ResourceDocument<T>>;
    fields(type: string, fields: string[]): ToOneRelationshipProxy;
    include(pointer: string): ToOneRelationshipProxy;
    param(name: string, value: string): ToOneRelationshipProxy;
    update(identifier: ResourceIdentifier, signal?: AbortSignal): Promise<ResourceIdentifierDocument>;
}
export type ToOneRelationship = Relationship & ToOneRelationshipProxy;
interface Filterable<R> {
    fields(type: string, fields: string[]): R;
    include(pointer: string): R;
    filter(expression: Expression | null): R;
    limit(limit: number | null): R;
    offset(offset: number | null): R;
    sort(field: string, desc: boolean): R;
    param(field: string, value: string): R;
}
export interface ToManyRelationshipProxy extends Filterable<ToManyRelationshipProxy> {
    data?: ResourceIdentifier[];
    self(signal?: AbortSignal): Promise<IdentifierCollectionDocument>;
    related<T extends Resource>(signal?: AbortSignal): Promise<CollectionDocument<T>>;
    delete(identifiers: ResourceIdentifier[], signal?: AbortSignal): Promise<IdentifierCollectionDocument>;
    update(identifiers: ResourceIdentifier[], signal?: AbortSignal): Promise<IdentifierCollectionDocument>;
    create(identifiers: ResourceIdentifier[], signal?: AbortSignal): Promise<IdentifierCollectionDocument>;
}
export type ToManyRelationship = Relationship & ToManyRelationshipProxy;
export type SelectCollection = {
    select<T extends Resource>(collection: string): CollectionMethods<T>;
};
export type CollectionMethods<T extends Resource> = Filterable<CollectionMethods<T>> & {
    self(signal?: AbortSignal): Promise<CollectionDocument<T>>;
    id(id: string): ResourceMethods<T>;
    create(data: PartialResource<Resource>, signal?: AbortSignal): Promise<ResourceDocument<T>>;
};
export interface CollectionDocument<T extends Resource> extends CompoundDocument<T[]> {
    data: ResourceObject<T>[];
    self(signal?: AbortSignal): Promise<CollectionDocument<T>>;
    next(signal?: AbortSignal): Promise<CollectionDocument<T> | undefined>;
    prev(signal?: AbortSignal): Promise<CollectionDocument<T> | undefined>;
    first(signal?: AbortSignal): Promise<CollectionDocument<T> | undefined>;
    last(signal?: AbortSignal): Promise<CollectionDocument<T> | undefined>;
}
export type ResourceMethods<T extends Resource> = {
    self(signal?: AbortSignal): Promise<ResourceDocument<T>>;
};
export interface ResourceDocument<T extends Resource> extends CompoundDocument<T> {
    data: ResourceObject<T>;
    self(signal?: AbortSignal): Promise<ResourceDocument<T>>;
}
export type ResourceIdentifierDocument = CompoundDocument<ResourceIdentifier> & {
    data: ResourceIdentifier | null;
    self(signal?: AbortSignal): Promise<ResourceIdentifierDocument>;
};
export type IdentifierCollectionDocument = CompoundDocument<ResourceIdentifier[]> & {
    data: ResourceIdentifier[];
    self(signal?: AbortSignal): Promise<IdentifierCollectionDocument>;
    next(signal?: AbortSignal): Promise<IdentifierCollectionDocument | undefined>;
    prev(signal?: AbortSignal): Promise<IdentifierCollectionDocument | undefined>;
    first(signal?: AbortSignal): Promise<IdentifierCollectionDocument | undefined>;
    last(signal?: AbortSignal): Promise<IdentifierCollectionDocument | undefined>;
};
declare const useJsonApiWithoutIndex: (client?: Client, baseURL?: string) => SelectCollection;
interface Index {
    [key: string]: Resource;
}
declare type ResourceList<T extends Index> = {
    [P in keyof T]: CollectionMethods<T[P]>;
};
declare const useJsonApiWithIndex: <T extends Index>(client?: Client, baseURL?: string) => Promise<ResourceList<T>>;
export { CompoundDocument, ResourceIdentifier, Resource, Meta, Link, Index, ResourceList, ODataExpressionStrategy, PrettyExpressionBuilder, QuatrodotExpressionStrategy, useNativeFetchClient, useJsonApiWithoutIndex, useJsonApiWithIndex };
