import { Expression, ExpressionStrategy } from "./Expression";
interface Operator {
    eq(): Value;
    ne(): Value;
    gt(): Value;
    ge(): Value;
    lt(): Value;
    le(): Value;
    be(): Range;
    in(): Value;
    has(): Value;
    startsWith(text: string): Compose;
    endsWith(text: string): Compose;
    contains(text: string): Compose;
    concat(fieldOrValue: Expression): Operator;
    indexOf(text: string): Operator;
    add(fieldOrValue: Expression): Operator;
    sub(fieldOrValue: Expression): Operator;
    mul(fieldOrValue: Expression): Operator;
    div(fieldOrValue: Expression): Operator;
    mod(fieldOrValue: Expression): Operator;
    not(field: Expression): Operator;
    matchesPattern(pattern: string): Compose;
    substring(length: number): Operator;
    toLower(): Operator;
    toUpper(): Operator;
    lengthOf(): Operator;
    trim(): Operator;
    floor(): Operator;
    ceiling(): Operator;
    round(): Operator;
    date(): Operator;
    day(): Operator;
    hour(): Operator;
    minute(): Operator;
    month(): Operator;
    second(): Operator;
    time(): Operator;
    year(): Operator;
    neg(): Operator;
}
interface Value {
    literal(value: any): Compose;
    /**
     * @deprecated use andX()/orX() instead
     */
    right(expression: Expression): Compose;
}
interface Range {
    literal(from: string | number, to: string | number): Compose;
}
interface Where {
    field(name: string): Operator;
}
interface Compose {
    and(): Where;
    or(): Where;
    build(): Expression | null;
}
interface Grouping {
    conjunct(...expressions: Expression[]): Compose & Grouping;
    disjunct(...expressions: Expression[]): Compose & Grouping;
}
export default function (strategy?: ExpressionStrategy): Where & Compose & Grouping;
export {};
