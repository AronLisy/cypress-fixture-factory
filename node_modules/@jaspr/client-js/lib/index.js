var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import useNativeFetchClient from "./NativeFetchClient";
import ODataExpressionStrategy from "./ODataExpressionStrategy";
import PrettyExpressionBuilder from "./PrettyExpressionBuilder";
import QuatrodotExpressionStrategy from "./QuatrodotExpressionStrategy";
let _http;
let _host;
let _id = null;
const normalize = (link) => {
    if (typeof link === 'string') {
        return link;
    }
    else {
        return link.href;
    }
};
const ErrorMessages = {
    missingLink(linkName) {
        return new Error(`Operation could not be executed because ${linkName} is missing.`);
    },
    dataNotProvided() {
        return new Error(`Cannot recognize cardinality of data.
        Relationships.data is not provided and Relationships.meta.collection is missing.`);
    }
};
const criteriaFactory = function () {
    let _fields = {};
    let _limit = null;
    let _offset = null;
    let _inclusion = [];
    let _expression = null;
    let _sortBy = {};
    let _params = {};
    return {
        param(name, value) {
            _params[name] = value;
            return this;
        },
        fields(type, fields) {
            fields = fields.concat(_fields[type] || []);
            _fields[type] = fields;
            return this;
        },
        include(path) {
            _inclusion.push(path);
            return this;
        },
        sort(field, desc = false) {
            _sortBy[field] = desc;
            return this;
        },
        limit(limit) {
            _limit = limit;
            return this;
        },
        offset(offset) {
            _offset = offset;
            return this;
        },
        filter(expression) {
            _expression = expression;
            return this;
        },
        toURL() {
            let query = '';
            let glue = '?';
            if (_limit !== null) {
                query += glue + 'page[limit]=' + _limit.toString();
                glue = '&';
            }
            if (_offset !== null) {
                query += glue + 'page[offset]=' + _offset.toString();
                glue = '&';
            }
            for (const field in _fields) {
                query += glue + `fields[${field}]=` + _fields[field].join();
                glue = '&';
            }
            if (_expression) {
                query += glue + 'filter=' + _expression.express();
                glue = '&';
            }
            if (_inclusion.length > 0) {
                query += glue + 'include=' + _inclusion.join();
                glue = '&';
            }
            const sort = [];
            for (const field in _sortBy) {
                const desc = _sortBy[field];
                sort.push(`${desc ? '-' : ''}${field}`);
            }
            if (sort.length) {
                query += glue + 'sort=' + sort.join(',');
                glue = '&';
            }
            for (const param in _params) {
                query += glue + `${[param]}=${_params[param]}`;
                glue = '&';
            }
            return query;
        }
    };
};
const bodyInitFactory = (data) => {
    return JSON.stringify({
        jsonapi: { version: '1.0' },
        data
    });
};
const toManyProcessor = (relationship) => {
    const criteria = criteriaFactory();
    const data = relationship.data;
    return Object.assign(Object.assign({}, relationship), { data,
        create(identifiers, signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.self) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.post(url.toString(), bodyInitFactory(identifiers), signal);
                    const doc = yield response.json();
                    return identifierCollectionDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        },
        delete(identifiers, signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.self) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.delete(url.toString(), bodyInitFactory(identifiers), signal);
                    const doc = yield response.json();
                    return identifierCollectionDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        },
        fields(type, fields) {
            criteria.fields(type, fields);
            return this;
        },
        filter(expression = null) {
            criteria.filter(expression);
            return this;
        },
        include(pointer) {
            criteria.include(pointer);
            return this;
        },
        limit(limit) {
            criteria.limit(limit);
            return this;
        },
        offset(offset) {
            criteria.offset(offset);
            return this;
        },
        sort(field, desc = true) {
            criteria.sort(field, desc);
            return this;
        },
        param(name, value) {
            criteria.param(name, value);
            return this;
        },
        related(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.related) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.related);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return collectionDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('related');
            });
        },
        self(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.self) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return identifierCollectionDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        },
        update(identifiers, signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.self) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.patch(url.toString(), bodyInitFactory(identifiers), signal);
                    const doc = yield response.json();
                    return identifierCollectionDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        } });
};
const toOneProcessor = (relationship) => {
    const criteria = criteriaFactory();
    return Object.assign(Object.assign({}, relationship), { fields(type, fields) {
            criteria.fields(type, fields);
            return this;
        },
        include(pointer) {
            criteria.include(pointer);
            return this;
        },
        param(name, value) {
            criteria.param(name, value);
            return this;
        },
        related(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.related) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.related);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return resourceDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('related');
            });
        },
        self(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.self) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return identifierDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        },
        update(identifier, signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (relationship.links && relationship.links.self) {
                    const query = criteria.toURL();
                    const endpoint = normalize(relationship.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.patch(url.toString(), bodyInitFactory(identifier), signal);
                    const doc = yield response.json();
                    return identifierDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        } });
};
const resourceProcessor = (resource) => {
    var _a, _b;
    const criteria = criteriaFactory();
    const relationships = {};
    for (const key in resource.relationships) {
        if (Array.isArray(resource.relationships[key].data) || ((_a = resource.relationships[key].meta) === null || _a === void 0 ? void 0 : _a.collection) === true) {
            relationships[key] = toManyProcessor(resource.relationships[key]);
        }
        else if (resource.relationships[key].data || ((_b = resource.relationships[key].meta) === null || _b === void 0 ? void 0 : _b.collection) === false) {
            relationships[key] = toOneProcessor(resource.relationships[key]);
        }
        else {
            throw ErrorMessages.dataNotProvided();
        }
    }
    return Object.assign(Object.assign({}, resource), { relationships,
        fields(type, fields) {
            criteria.fields(type, fields);
            return this;
        },
        include(pointer) {
            criteria.include(pointer);
            return this;
        },
        param(name, value) {
            criteria.param(name, value);
            return this;
        },
        self(signal) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                if (resource.links && ((_a = resource.links) === null || _a === void 0 ? void 0 : _a.self)) {
                    const query = criteria.toURL();
                    const endpoint = normalize(resource.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return resourceDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        },
        update(data, signal) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                if (resource.links && ((_a = resource.links) === null || _a === void 0 ? void 0 : _a.self)) {
                    const query = criteria.toURL();
                    const endpoint = normalize(resource.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.patch(url.toString(), bodyInitFactory(data), signal);
                    const doc = yield response.json();
                    return resourceDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        },
        delete(signal) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                if (resource.links && ((_a = resource.links) === null || _a === void 0 ? void 0 : _a.self)) {
                    const query = criteria.toURL();
                    const endpoint = normalize(resource.links.self);
                    const url = new URL(`${endpoint}${query}`);
                    const response = yield _http.delete(url.toString(), undefined, signal);
                    if (response.status === 204) {
                        return undefined;
                    }
                    const doc = yield response.json();
                    return resourceDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        } });
};
const collectionProcessor = (document) => {
    if (document.data) {
        const data = [];
        document.data.forEach(resource => {
            data.push(resourceProcessor(resource));
        });
        return Object.assign(Object.assign({}, document), { data });
    }
    else {
        throw document;
    }
};
const collectionDocumentProcessor = (document) => {
    const doc = collectionProcessor(document);
    const data = doc.data;
    return Object.assign(Object.assign({}, doc), { data,
        first(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (document.links && document.links.first) {
                    const url = new URL(normalize(document.links.first));
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return collectionDocumentProcessor(doc);
                }
                return undefined;
            });
        },
        last(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (document.links && document.links.last) {
                    const url = new URL(normalize(document.links.last));
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return collectionDocumentProcessor(doc);
                }
                return undefined;
            });
        },
        next(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (document.links && document.links.next) {
                    const url = new URL(normalize(document.links.next));
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return collectionDocumentProcessor(doc);
                }
                return undefined;
            });
        },
        prev(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (document.links && document.links.prev) {
                    const url = new URL(normalize(document.links.prev));
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return collectionDocumentProcessor(doc);
                }
                return undefined;
            });
        },
        self(signal) {
            return __awaiter(this, void 0, void 0, function* () {
                if (document.links && document.links.self) {
                    const url = new URL(normalize(document.links.self));
                    const response = yield _http.get(url.toString(), signal);
                    const doc = yield response.json();
                    return collectionDocumentProcessor(doc);
                }
                throw ErrorMessages.missingLink('self');
            });
        } });
};
const resourceDocumentProcessor = (document) => {
    if (document.data) {
        const data = resourceProcessor(document.data);
        return Object.assign(Object.assign({}, document), { data,
            self(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.self) {
                        const url = new URL(normalize(document.links.self));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return resourceDocumentProcessor(doc);
                    }
                    throw ErrorMessages.missingLink('self');
                });
            } });
    }
    else {
        throw document;
    }
};
const identifierCollectionDocumentProcessor = (document) => {
    if (document.data) {
        const data = document.data;
        return Object.assign(Object.assign({}, document), { data,
            first(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.first) {
                        const url = new URL(normalize(document.links.first));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return identifierCollectionDocumentProcessor(doc);
                    }
                    return undefined;
                });
            },
            last(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.last) {
                        const url = new URL(normalize(document.links.last));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return identifierCollectionDocumentProcessor(doc);
                    }
                    return undefined;
                });
            },
            next(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.next) {
                        const url = new URL(normalize(document.links.next));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return identifierCollectionDocumentProcessor(doc);
                    }
                    return undefined;
                });
            },
            prev(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.prev) {
                        const url = new URL(normalize(document.links.prev));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return identifierCollectionDocumentProcessor(doc);
                    }
                    return undefined;
                });
            },
            self(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.self) {
                        const url = new URL(normalize(document.links.self));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return identifierCollectionDocumentProcessor(doc);
                    }
                    throw ErrorMessages.missingLink('self');
                });
            } });
    }
    else {
        throw document;
    }
};
const identifierDocumentProcessor = (document) => {
    if (document.data) {
        const data = document.data;
        return Object.assign(Object.assign({}, document), { data,
            self(signal) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (document.links && document.links.self) {
                        const url = new URL(normalize(document.links.self));
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return identifierDocumentProcessor(doc);
                    }
                    throw ErrorMessages.missingLink('self');
                });
            } });
    }
    else {
        throw document;
    }
};
const useJsonApiWithoutIndex = (client, baseURL) => {
    _http = client !== null && client !== void 0 ? client : useNativeFetchClient();
    _http.setHeader('Accept', 'application/vnd.api+json');
    _http.setHeader('Content-Type', 'application/vnd.api+json');
    _host = baseURL !== null && baseURL !== void 0 ? baseURL : `${window.location.protocol}://${window.location.host}`;
    return {
        select(collection) {
            const criteria = criteriaFactory();
            const type = collection;
            return {
                create(data, signal) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const query = criteria.toURL();
                        const url = new URL(`${_host}/${type}${query}`);
                        const response = yield _http.post(url.toString(), bodyInitFactory(data), signal);
                        const doc = yield response.json();
                        return resourceDocumentProcessor(doc);
                    });
                },
                fields(type, fields) {
                    criteria.fields(type, fields);
                    return this;
                },
                filter(expression = null) {
                    criteria.filter(expression);
                    return this;
                },
                id(id) {
                    _id = id;
                    return {
                        self(signal) {
                            return __awaiter(this, void 0, void 0, function* () {
                                const query = criteria.toURL();
                                const url = new URL(`${_host}/${type}/${_id}${query}`);
                                const response = yield _http.get(url.toString(), signal);
                                const doc = yield response.json();
                                return resourceDocumentProcessor(doc);
                            });
                        }
                    };
                },
                include(pointer) {
                    criteria.include(pointer);
                    return this;
                },
                limit(limit) {
                    criteria.limit(limit);
                    return this;
                },
                offset(offset) {
                    criteria.offset(offset);
                    return this;
                },
                sort(field, desc = true) {
                    criteria.sort(field, desc);
                    return this;
                },
                param(name, value) {
                    criteria.param(name, value);
                    return this;
                },
                self(signal) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const query = criteria.toURL();
                        const url = new URL(`${_host}/${collection}${query}`);
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return collectionDocumentProcessor(doc);
                    });
                }
            };
        }
    };
};
const useJsonApiWithIndex = function (client, baseURL) {
    return __awaiter(this, void 0, void 0, function* () {
        _http = client !== null && client !== void 0 ? client : useNativeFetchClient();
        _http.setHeader('Accept', 'application/vnd.api+json');
        _http.setHeader('Content-Type', 'application/vnd.api+json');
        _host = baseURL !== null && baseURL !== void 0 ? baseURL : `${window.location.protocol}://${window.location.host}/`;
        let response;
        const indexEndpoint = (_host + '/').replace(/\/+$/, '/');
        response = yield (yield _http.get(indexEndpoint)).json();
        const select = (endpoint) => {
            const criteria = criteriaFactory();
            return {
                create(data, signal) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const query = criteria.toURL();
                        const url = new URL(`${endpoint}${query}`);
                        const response = yield _http.post(url.toString(), bodyInitFactory(data), signal);
                        const doc = yield response.json();
                        return resourceDocumentProcessor(doc);
                    });
                },
                fields(type, fields) {
                    criteria.fields(type, fields);
                    return this;
                },
                filter(expression = null) {
                    criteria.filter(expression);
                    return this;
                },
                id(id) {
                    _id = id;
                    return {
                        self(signal) {
                            return __awaiter(this, void 0, void 0, function* () {
                                const query = criteria.toURL();
                                const url = new URL(`${endpoint}/${_id}${query}`);
                                const response = yield _http.get(url.toString(), signal);
                                const doc = yield response.json();
                                return resourceDocumentProcessor(doc);
                            });
                        }
                    };
                },
                include(pointer) {
                    criteria.include(pointer);
                    return this;
                },
                limit(limit) {
                    criteria.limit(limit);
                    return this;
                },
                offset(offset) {
                    criteria.offset(offset);
                    return this;
                },
                sort(field, desc = true) {
                    criteria.sort(field, desc);
                    return this;
                },
                param(name, value) {
                    criteria.param(name, value);
                    return this;
                },
                self(signal) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const query = criteria.toURL();
                        const url = new URL(`${endpoint}${query}`);
                        const response = yield _http.get(url.toString(), signal);
                        const doc = yield response.json();
                        return collectionDocumentProcessor(doc);
                    });
                }
            };
        };
        const ret = {};
        for (const type in response.links) {
            const link = response.links[type];
            if (link) {
                let endpoint;
                if (typeof link !== 'string') {
                    endpoint = link.href;
                }
                else {
                    endpoint = link;
                }
                Object.defineProperty(ret, type, {
                    get: () => {
                        return select(endpoint);
                    },
                    configurable: true
                });
            }
        }
        return ret;
    });
};
export { ODataExpressionStrategy, PrettyExpressionBuilder, QuatrodotExpressionStrategy, useNativeFetchClient, useJsonApiWithoutIndex, useJsonApiWithIndex };
