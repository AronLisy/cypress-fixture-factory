import { Constants } from "./Filter";
const unsupported = [
    Constants.FUNCTION_CONCAT,
    Constants.FUNCTION_INDEX_OF,
    Constants.FUNCTION_LENGTH,
    Constants.FUNCTION_SUBSTRING,
    Constants.ARITHMETIC_ADDITION,
    Constants.ARITHMETIC_SUBTRACTION,
    Constants.ARITHMETIC_NEGATION,
    Constants.ARITHMETIC_MULTIPLICATION,
    Constants.ARITHMETIC_DIVISION,
    Constants.ARITHMETIC_MODULO,
    Constants.FUNCTION_MATCHES_PATTERN,
    Constants.FUNCTION_TO_LOWER,
    Constants.FUNCTION_TO_UPPER,
    Constants.FUNCTION_TRIM,
    Constants.FUNCTION_DATE,
    Constants.FUNCTION_DAY,
    Constants.FUNCTION_HOUR,
    Constants.FUNCTION_MINUTE,
    Constants.FUNCTION_MONTH,
    Constants.FUNCTION_NOW,
    Constants.FUNCTION_SECOND,
    Constants.FUNCTION_TIME,
    Constants.FUNCTION_YEAR,
    Constants.FUNCTION_CEILING,
    Constants.FUNCTION_FLOOR,
    Constants.FUNCTION_ROUND,
];
const check = (constant) => {
    if (unsupported.includes(constant)) {
        throw new Error(`Unsupported operator ${constant}.`);
    }
};
const field = function (name) {
    return {
        express() {
            return name;
        }
    };
};
const literal = function (value) {
    let _value;
    if (value === undefined) {
        throw new Error('Expected value to by one of [null, Date, String, Number, Boolean, Array], but got ' + typeof value);
    }
    if (value === null) {
        _value = 'null';
    }
    else {
        if (typeof value.express === 'function') {
            _value = value.express();
        }
        else if (value instanceof Date) {
            _value = `${value.toISOString()}`;
        }
        else if (value instanceof Array) {
            value = value.map(item => literal(item).express());
            _value = `${value.join('::')}`;
        }
        else if (typeof value === 'string') {
            _value = `${value}`;
        }
        else if (typeof value === 'boolean') {
            _value = value ? 'true' : 'false';
        }
        else if (typeof value === 'number') {
            _value = value.toString();
        }
        else {
            throw new Error('Expected value to by one of [null, Date, String, Number, Boolean, Array], but got ' + typeof value);
        }
    }
    return {
        express: function () {
            return _value;
        }
    };
};
const groupExpression = function (expressions = []) {
    let _expressions = expressions;
    return {
        addExpression(expression) {
            _expressions.push(expression);
            return this;
        },
        express() {
            return `${_expressions.map(item => item.express()).join('|')}`;
        }
    };
};
const binaryExpression = function (left, operator, right) {
    check(operator);
    return {
        express() {
            if ([Constants.LOGICAL_AND, Constants.LOGICAL_OR].includes(operator)) {
                return `${left.express()}|${right.express()}`;
            }
            return `${left.express()}::${operator}::${right.express()}`;
        }
    };
};
const functionExpression = function (fn, args) {
    check(fn);
    const left = args[0];
    const right = args[1];
    return {
        express() {
            return `${left.express()}::${fn}::${right.express()}`;
        }
    };
};
const unaryExpression = function (value, operator) {
    throw new Error("Unsupported expression.");
};
const QuatrodotExpressionBuilder = {
    field,
    literal,
    unaryExpression,
    groupExpression,
    binaryExpression,
    functionExpression,
};
export default QuatrodotExpressionBuilder;
